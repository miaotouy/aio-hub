# 项目未来功能与重构计划 (TODO)

本文档记录了项目未来的开发方向和待办事项，用于规划和追踪长期目标。

## 🎯 当前开发重点

### 阶段一：核心架构完善

#### 1.1 工具结构重构 (高优先级)
- [x] **探索设计方案**：
  - [x] 调研 Service Locator 和 Dependency Injection 模式在 Vue 3 中的最佳实践
  - [x] 设计对现有结构破坏性最小、但收益最高的方案
  - [x] 评估重构对现有工具的影响范围
  
- [x] **业务逻辑分离**：
  - [x] 将工具的核心逻辑抽离为独立的 Service 类
  - [x] 设计统一的工具注册接口（注册元数据、能力声明、依赖关系等）
  - [x] 实现工具发现机制（支持动态加载、热重载）
  
- [x] **调用机制实现**：
  - [x] 设计统一的工具调用协议（输入/输出规范、错误处理）
  - [x] 实现工具间的依赖注入和通信机制
  - [-] （二阶段实现这个）实现基于纯文本解析的工具调用协议（类似 Agent 可用工具）

#### 1.2 多模态处理增强
- [ ] **自动降维处理**：
  - [x] 实现模型能力检测逻辑 (`src/composables/useModelMetadata.ts`)
  - [ ] **集成 OCR**: 在 `useChatHandler` 中，为不支持图片输入的模型自动调用 `smart-ocr` 服务进行转写。(依赖: `smartOcr.service.ts` 已提供 `processImages` 接口)
  - [ ] **集成 ASR (新功能)**: 集成语音识别服务，自动转写音视频内容为文本。
  - [ ] 在上下文构建时智能选择原始内容或转写文本。

---

## 🚀 未来规划

### 阶段二：Chat 模块深化

#### 2.1 基于文本的工具调用 (Text-based Tool Calling)
> 核心思路：不依赖特定模型的 Function Calling API，而是通过引导和解析模型输出的特定格式文本来实现工具调用，确保方案的通用性和可控性。
- [ ] **工具调用能力** (依赖：`src/services/executor.ts` 已提供底层支持)：
  - [ ] 在 `useChatHandler` 中增加工具调用逻辑：引导 LLM 生成 `ToolCall` JSON。
  - [ ] 解析 LLM 输出，识别并执行 `ToolCall` 请求（调用 `execute` 函数）。
  - [ ] 设计工具调用的参数验证和错误处理机制。
  - [ ] 实现工具调用结果的自动注入到上下文
  - [ ] 支持多步工具调用（链式调用、并行调用）

#### 2.2 用户档案增强
- [ ] **高级档案功能**：
  - [ ] 支持自定义档案内容在上下文中的插入位置（前置、后置、替换等）
  - [ ] 实现档案模板系统（预设角色、场景等）
  - [ ] 支持档案继承和组合（基础档案 + 扩展档案）

### 阶段三：新工具开发

#### 3.1 视频解析与归档工具
- [ ] **核心功能**：
  - [ ] 实现对主流视频网站的视频信息爬取（Bilibili、YouTube 等）
  - [ ] 支持下载视频的字幕、弹幕和评论区内容
  - [ ] 将解析后的文本内容归档为结构化数据
  - [ ] 与 Chat 模块集成，支持直接引用视频内容作为上下文

#### 3.2 酒馆内容导入工具
- [ ] **格式设计**：
  - [ ] 参考酒馆和其他平台，设计项目自有的角色卡/场景文件格式
  - [ ] 确保格式的可扩展性和向后兼容性
  
- [ ] **导入功能**：
  - [ ] 实现对酒馆格式的解析和导入
  - [ ] 转换为项目自有格式，保留核心信息
  - [ ] 支持批量导入和预览

### 阶段四：用户体验优化

#### 4.1 UI/UX 整体提升
- [ ] **布局优化**：
  - [ ] 优化整体界面布局，提升空间利用率
  - [ ] 改进响应式设计，适配不同窗口尺寸
  - [ ] 统一视觉语言，提升一致性和美观度

#### 4.2 国际化 (i18n)
- [ ] **基础设施**：
  - [ ] 引入 vue-i18n 框架
  - [ ] 设计翻译文件结构和命名规范
  
- [ ] **内容迁移**：
  - [ ] 识别并提取所有硬编码文本
  - [ ] 逐步替换为 i18n key
  - [ ] 提供至少中文和英文两种语言

#### 4.3 新手引导 (Onboarding)
- [ ] **引导系统**：
  - [ ] 设计首次启动的欢迎界面
  - [ ] 实现工具列表的快速配置
  - [ ] 提供核心功能的交互式教程
  
- [ ] **个性化设置**：
  - [ ] 允许用户自定义默认显示的工具
  - [ ] 支持工具分组和自定义标签
  - [ ] 简化主界面，提升易用性

### 阶段五：核心理念与长期目标

#### 5.1 工具设计哲学
- [ ] **工具离线化**：优先保证核心工具的离线可用性，减少对网络连接的依赖，确保在断网环境下依然高效。
- [ ] **透明化与人性化**：工具设计应直观、易于人类直接操作，避免成为只能由 AI 调用的“黑盒”。在 AI 自动化和人类手动控制之间寻求平衡，让用户始终拥有选择权和控制权。

---

## 📝 技术债务与优化

### 性能优化
- [ ] 优化大型对话的渲染性能（虚拟滚动、懒加载）
- [ ] 减少不必要的响应式更新（shallowRef、markRaw）
- [ ] 优化资产管理的内存占用

### 代码质量
- [ ] 增加单元测试覆盖率（核心 composables、工具逻辑）
- [ ] 完善 TypeScript 类型定义（减少 any 使用）
- [ ] 统一代码风格和注释规范

### 文档完善
- [ ] 补充各工具的使用文档
- [ ] 编写开发者指南（如何添加新工具、如何扩展功能）
- [ ] 创建贡献指南（代码规范、PR 流程）

---

## 💡 创意与探索

### 潜在功能
- [ ] 探索本地 LLM 集成（通过 `llm-proxy` 或直接集成 Ollama、LM Studio 等）
- [ ] 研究语音交互功能（TTS/STT），可与 ASR 任务合并
- [ ] 调研知识库管理（RAG、向量数据库）
- [ ] 考虑插件系统（允许第三方扩展），可能是对当前服务架构的进一步封装

### 社区建设
- [ ] 建立用户反馈渠道
- [ ] 创建示例和最佳实践库
- [ ] 组织功能投票和优先级排序
