# 统一插件系统设计文档

## 1. 概述

### 1.1. 设计目标

本设计旨在为 AIO Hub 应用构建一个统一、可扩展、安全且易于开发的插件系统。其核心目标如下：

- **统一调用**: 无论是内置功能、轻量级前端插件，还是重型后端插件，都通过统一的接口进行调用。
- **保持核心轻量**: 允许将功能复杂、依赖庞大的模块（如视频处理）作为可选插件分发，避免主应用体积膨胀。
- **隔离与稳定**: 保证第三方插件的异常或崩溃不会影响主应用的稳定性。
- **良好开发体验**: 为插件开发者，特别是我们自己，提供一个顺畅、高效的开发和调试流程。

### 1.2. 核心理念

系统遵循“万物皆服务”的理念，建立在应用现有的服务架构之上。所有可执行单元都被抽象为 `ToolService`，通过中央注册表 `ServiceRegistry` 进行管理，并由统一的 `Executor` 调度执行。

## 2. 核心架构

本插件系统完全基于并扩展现有的服务层 (`src/services/`)。

- **`ToolService` 接口 (`types.ts`)**: 所有插件都将被封装成符合此接口的代理对象，拥有统一的生命周期和元数据。
- **`ServiceRegistry` (`registry.ts`)**: 单例的服务注册表，是所有可用功能（无论是内置还是插件）的管理中心。
- **`Executor` (`executor.ts`)**: 统一的服务调用入口，上层业务逻辑通过 `execute({ service, method, params })` 与所有功能交互，无需关心其具体实现和来源。

## 3. 插件类型

为了兼顾灵活性和稳定性，系统支持两种类型的插件：

### 3.1. JavaScript (JS) 插件

- **用途**: 用于实现轻量级的、与UI交互紧密的、无原生依赖的逻辑。例如：文本格式化工具、API调用封装、自定义主题等。
- **运行环境**: 直接在 Vite 前端环境中运行，与主应用共享同一个渲染进程。
- **优点**: 开发简单，可利用 HMR 实现热重载，能直接访问 DOM 和前端 API。
- **限制**: 无法执行计算密集型任务，无法直接操作文件系统或调用原生库。

### 3.2. Sidecar 插件

- **用途**: 用于实现重型的、计算密集型的、需要原生依赖或独立运行环境的功能。例如：视频硬字幕提取、文件批量处理、启动本地服务器等。
- **运行环境**: 作为一个独立的外部子进程 (`.exe`) 运行，与主应用完全隔离。
- **通信方式**: 主应用通过标准输入输出 (`stdin/stdout`) 与 Sidecar 进程进行基于 JSON 的消息通信。
- **优点**: 绝对的进程隔离保证了主应用的稳定；插件可以使用任何语言（Rust, Python, Go）编写；完美解决原生依赖和应用体积问题。
- **限制**: 开发复杂度较高，无法直接与 UI 交互（只能通过事件向前端发送数据）。

## 4. 插件生命周期管理

### 4.1. 发现与安装

- **插件市场**: 应用内提供“扩展”页面，从一个远程 Git 仓库拉取 `index.json` 插件索引。
- **智能分发**: 客户端会根据当前运行的操作系统和CPU架构，智能地执行以下操作：
  - **平台兼容性检查**: 在市场列表中，自动过滤或置灰当前平台不支持的插件。
  - **按需下载**: 当用户安装插件时，仅下载适配当前平台的最小化包，避免了下载用户无法使用的二进制文件，极大地优化了用户体验。
- **安装方式**:
  1.  **从市场安装**: 一键下载适配当前平台的插件 `.zip` 包并自动解压到插件目录 (`appDataDir/plugins/`)。
  2.  **从本地安装**: 允许用户手动选择一个 `.zip` 包进行安装。

### 4.2. 管理

在“扩展”页面的“已安装”标签页中，用户可以对插件进行管理：

- **启用/禁用**: 动态加载或卸载一个插件，无需重启应用。
- **更新**: 当市场中的插件版本高于本地版本时，提示用户更新。
- **卸载**: 从文件系统彻底删除插件。

## 5. 开发体验

### 5.1. 开发模式

为了提供极致的开发便利性，应用通过 `import.meta.env.DEV` 环境变量区分模式：

- **生产模式**: 从 `appDataDir/plugins/` 加载已安装的、编译后的插件。
- **开发模式**: 直接从项目根目录下的 `/plugins` 文件夹加载插件的 TypeScript 源码。

此模式利用 Vite 的能力，为 JS 插件提供了开箱即用的 **热模块重载 (HMR)**，实现了修改代码后立即生效的顺畅体验。

### 5.2. 插件模板与 SDK

我们将提供：
- 一个官方的 CLI 工具 (`create-aio-hub-plugin`)，用于快速生成包含完整 TS 配置、**多平台编译**和**智能打包**脚本的插件项目模板。
- 一个 `@aio-hub/sdk` 包，为插件开发提供类型定义和工具函数（如安全的后端IPC调用接口）。

## 6. 技术规范

### 6.1. 插件包结构 (`.zip`)

```
my-cool-plugin/
├── bin/
│   └── extractor.exe  # (Sidecar 插件) 可执行文件
├── index.js           # (JS 插件) 编译后的入口文件
└── manifest.json      # 插件清单，必须存在
```

### 6.2. `manifest.json` 详解

这是插件的灵魂，定义了其所有属性。

```json
{
  "id": "unique-plugin-id",
  "name": "插件显示名称",
  "version": "1.0.0",
  "description": "插件的详细描述。",
  "author": "作者名",
  "host": { "appVersion": ">=2.0.0" },

  // --- 核心类型定义 ---
  "type": "javascript" | "sidecar",

  // --- JS 插件专用 ---
  "main": "index.js", // JS 入口文件

  // --- Sidecar 插件专用 ---
  // --- Sidecar 插件专用 ---
  "sidecar": {
    // 按平台指定可执行文件，由打包脚本自动生成
    "executable": {
      "win32-x64": "bin/extractor-win-x64.exe",
      "darwin-arm64": "bin/extractor-macos-arm64.app/Contents/MacOS/extractor"
    },
    "args": ["--input", "{{inputFile}}"] // 命令行参数模板
  },

  // --- 暴露给 Executor 的方法 ---
  "methods": [
    {
      "name": "methodName",
      "description": "方法描述",
      "parameters": [
        { "name": "paramName", "type": "string", "required": true }
      ]
    }
  ],

  // --- 权限声明 (未来) ---
  "permissions": [
    "fs:read:self", // 只能读写自己目录的文件
    "notification:show" // 可以显示系统通知
  ]
}
```

### 6.3. JS 插件 API

JS 插件的入口文件 (`main`) 必须 `export default` 一个对象，其包含了 `manifest.json` 中 `methods` 字段声明的所有方法。

```javascript
// index.js
function methodName({ paramName }) {
  // ... a lot of magic
  return `Hello, ${paramName}`;
}

export default {
  methodName,
};
```

### 6.4. Sidecar 通信协议

- **调用**: 主应用通过命令行参数将输入传递给 Sidecar 进程。
- **响应**: Sidecar 通过向 `stdout` 打印 **以换行符分隔的 JSON 字符串** 来回传数据。
- **消息格式**:
  - **进度**: `{"type": "progress", "percent": 30, "message": "正在处理..."}`
  - **结果**: `{"type": "result", "data": { ... }}`
  - **错误**: `{"type": "error", "message": "发生错误"}` (也可以通过 `stderr` 输出)

## 7. 实施计划

1.  **阶段一：核心机制与开发模式**
    - [ ] 实现 `LocalPluginProxy` 和 `LocalPluginAdapter`。
    - [ ] 实现“开发模式”，支持从 `/plugins` 目录热加载 JS 插件源码。
    - [ ] 手动创建一个示例 JS 插件，验证加载和执行链路。

2.  **阶段二：Sidecar 支持**
    - [ ] 在 Rust 后端添加 `execute_sidecar` 指令。
    - [ ] 扩展 `LocalPluginAdapter` 以支持 `sidecar` 类型的插件。
    - [ ] 创建一个示例 Sidecar 插件（可用 Rust 或 Python 编写），验证进程启动和通信。

3.  **阶段三：插件管理 UI**
    - [ ] 创建“扩展”页面，实现已安装插件的列表、启用/禁用和卸载功能。

4.  **阶段四：插件市场与生态**
    - [ ] 实现从远程 `index.json` 拉取和**按平台智能展示**插件市场。
    - [ ] 实现**按平台**一键安装和更新功能。
    - [ ] 撰写开发者文档并创建 `create-aio-hub-plugin` 模板项目。
