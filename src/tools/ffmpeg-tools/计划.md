# FFmpeg 多媒体工作台 (FFmpeg Tools): 架构与开发者指南

本文档旨在解析 `ffmpeg-tools` 工具的内部架构、设计理念和数据流。

## 1. 核心概念 (Core Concepts)

`ffmpeg-tools` 是一个基于 FFmpeg 的 GUI 封装工具，旨在提供直观的多媒体处理能力，并作为 AI 工作流（转写、聊天）的上游处理站。

### 1.1. 任务驱动 (Task-Driven)

处理过程被抽象为一系列异步任务。每个任务包含输入、输出、参数配置及当前状态（等待、处理中、已完成、失败）。

### 1.2. 资产系统解耦 (Asset System Decoupling)

- **独立存储**: 处理后的结果默认存储在用户指定的本地工作路径（未配置时默认为输入文件的路径），不直接进入应用的 Asset 数据库。
- **按需联动**: 仅在用户显式触发“发送”操作时，才将结果对接至资产系统。

### 1.3. 自动联动 (Integration Pipeline)

- **Chat 联动**: 利用 `llm-chat` 的附件收录机制，将处理后的文件路径直接注入对话输入框。

## 2. 核心组件与数据流

### 2.1. 逻辑分层

- **Registry (外观层)**: `ffmpegTools.registry.ts` 定义工具自注册元数据，遵循 `ToolRegistry` 接口。
- **Store (状态层)**: `ffmpegStore.ts` 负责：
  - 持久化配置（FFmpeg 路径、默认输出目录、硬件加速偏好）。
  - 维护响应式任务队列 `tasks: FfmpegTask[]`。
  - 任务状态持久化（利用 `pinia-plugin-persistedstate`）。
- **Composables (业务层)**:
  - `useFfmpegCore.ts`: 封装后端命令调用、进度监听（Tauri Events）、任务生命周期管理。
  - `useFfmpegIntegration.ts`: 处理与 Chat 和转写工具的联动逻辑。
- **Components (视图层)**: 采用响应式布局，提供参数配置、预览及任务管理。

### 2.2. 处理管道 (Processing Pipeline)

1.  **输入**: 用户拖入文件，调用 `get_media_metadata` 获取详细信息并填充 `MediaInfoCard`。
2.  **配置**: 用户选择模式并调整参数。支持“硬件加速”开关（若系统支持）。
3.  **调度**: 任务进入 `pending` 队列，根据并发限制（默认 2）由 `useFfmpegCore` 触发执行。
4.  **执行与反馈**:
    - 后端启动 FFmpeg 进程并解析 `-progress` 流。
    - 通过 `ffmpeg-progress` 事件实时回传 `FfmpegProgress` 数据。
5.  **交付**: 任务完成后，用户可一键定位文件或发送至其他 AI 工具。

### 2.3. 后端命令规格 (Backend Commands)

| 命令                        | 职责             | 关键参数                                               |
| --------------------------- | ---------------- | ------------------------------------------------------ |
| `get_media_metadata`        | 提取音视频元数据 | `input_path`, `ffmpeg_path`                            |
| `process_media`             | 核心处理命令     | `FfmpegParams` (含 mode, crf, bitrate, scale, hwaccel) |
| `check_ffmpeg_availability` | 路径校验         | `path`                                                 |
| `kill_ffmpeg_process`       | 强制终止任务     | `task_id`                                              |

## 3. 跨模块交互

### 3.1. 与 LLM Chat 协作

- 流程：`ffmpeg-tools` -> `llmChatRegistry.addAttachmentsFromPaths([path])`。
- 特点：利用 Chat 模块现有的文件解析和 Asset 转换逻辑，支持直接将处理后的路径注入输入框。

### 3.2. 与 Transcription 协作

- 流程：`ffmpeg-tools` -> `assetManagerEngine.importAssetFromPath(path)` -> `transcriptionRegistry.addTask(asset)`。
- 特点：支持视频/音频处理后的自动转写联动。

## 4. 关键类型定义

### 4.1. 任务模型

```typescript
interface FfmpegTask {
  id: string;
  name: string;
  inputPath: string;
  outputPath: string;
  mode: "compress" | "extract_audio" | "convert";
  status: "pending" | "processing" | "completed" | "failed" | "cancelled";
  progress: FfmpegProgress;
  error?: string;
  createdAt: number;
  completedAt?: number;
}

interface FfmpegProgress {
  percent: number; // 0-100
  currentTime: number; // 处理进度(秒)
  speed: string; // 如 "1.5x"
  bitrate: string;
}
```

### 4.2. 全局配置

```typescript
interface FfmpegConfig {
  ffmpegPath: string;
  defaultWorkDir: string;
  maxConcurrentTasks: number;
  hardwareAcceleration: boolean; // 是否开启 NVENC/QSV 等
  autoCleanup: boolean;
}
```

## 5. 开发者指南

### 5.1. 添加新处理模式

1.  在 `types.ts` 中定义新的 `ProcessingMode`。
2.  在 `ProcessingPanel.vue` 中添加对应的参数配置 UI。
3.  在后端 `video_processor.rs` 中扩展参数解析逻辑。

### 5.2. 调试

- 开启 `logger` 以观察 FFmpeg 的原始 stderr 输出，这对于排查编码错误至关重要。

## 6. UI 架构 (UI Architecture)

为了保持与 `transcription` 等工具的一致性，UI 采用标签页结构，将“即时操作”与“后台任务”分离。

### 6.1. 整体布局 (Overall Layout)

采用 `el-tabs` 作为顶层导航：

- **工作台 (Workbench)**: 核心交互区，负责文件导入、参数配置和预览。
- **任务监控 (Task Monitor)**: 实时展示所有异步处理任务的状态、进度及日志。
- **全局配置 (Settings)**: FFmpeg 路径、默认输出目录及清理策略。

### 6.2. 核心组件 (Core Components)

| 组件                   | 职责                                                         |
| ---------------------- | ------------------------------------------------------------ |
| `FfmpegWorkbench.vue`  | 容器组件，协调导入、配置与预览的交互逻辑。                   |
| `FileDropZone.vue`     | 强化版拖放区，支持文件夹拖入及文件类型过滤。                 |
| `MediaInfoCard.vue`    | 展示输入文件的元数据（编码、码率、分辨率、时长）。           |
| `ProcessingConfig.vue` | 动态表单，根据选定的 `ProcessingMode` 渲染不同的参数输入项。 |
| `TaskItem.vue`         | 任务队列中的单个条目，包含进度条、状态图标及结果操作按钮。   |
| `PreviewPlayer.vue`    | 集成 `VideoPlayer`，用于处理前的快速预览。                   |

### 6.3. 典型交互流程 (Interaction Flow)

1.  **导入阶段**: 用户拖入视频，`useFfmpegCore` 提取元数据并填充 `MediaInfoCard`。
2.  **配置阶段**: 用户选择模式（如“视频压缩”），`ProcessingConfig` 展开 CRF 和分辨率限制选项。
3.  **提交阶段**: 点击“开始”，任务对象被推入 `ffmpegStore` 的队列，并自动触发后台执行。
4.  **反馈阶段**: 用户切换至“任务监控”标签，查看实时进度流。
5.  **交付阶段**: 任务完成，点击“发送至 Chat”调用 `useFfmpegIntegration` 完成跨模块联动。
