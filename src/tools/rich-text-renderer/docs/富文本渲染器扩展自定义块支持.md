# 富文本渲染器扩展自定义块支持（草案）

## 1. 背景与目标

当前 Rich Text Renderer 主要支持 Markdown 标准语法和 XML 风格的标签（通过 `LlmThinkRule`）。为了支持 VCP (Variable & Command Protocol) 协议中的特殊标记以及未来可能出现的其他自定义格式，我们需要对渲染引擎进行扩展。

### VCP 协议示例

**工具调用请求块**：

```text
<<<[TOOL_REQUEST]>>>
tool_name:「始」SciCalculator「末」,
expression:「始」(1+5)*2「末」
<<<[END_TOOL_REQUEST]>>>
```

**日记写入块**：

```text
<<<DailyNoteStart>>>
...
<<<DailyNoteEnd>>>
```

这些标记使用自定义定界符（Delimiters），而非标准的 XML 标签，因此现有的解析机制无法直接支持。

## 2. 当前架构限制

1.  **Tokenizer 局限性**：
    - 目前基于正则和状态机，硬编码了 Markdown 和 HTML 标签的识别逻辑。
    - 不支持动态注册新的 Token 类型或识别规则。

2.  **LlmThinkRule 局限性**：
    - 设计初衷仅为了支持 `<think>` 等 XML 风格标签。
    - 类型定义限制为 `kind: 'xml_tag'`。

3.  **组件注册局限性**：
    - `AstNodeRenderer` 中的 `componentMap` 是静态定义的，插件无法注册新的渲染组件。

## 3. 架构设计方案

本方案采用**平行架构**：`LlmThinkRule` 保持不变，新增独立的 `CustomBlockRule` 系统。两者是平级关系，各自独立演进。

### 3.1 架构总览

```
┌─────────────────────────────────────────────────────┐
│                   渲染引擎核心                        │
├─────────────────────────────────────────────────────┤
│                    Tokenizer                        │
│  ┌─────────────────┐    ┌─────────────────────────┐ │
│  │  LlmThinkRule   │    │   CustomBlockRule[]     │ │
│  │  (内置，XML风格) │    │  (可扩展，多种模式)      │ │
│  └────────┬────────┘    └───────────┬─────────────┘ │
│           │                         │               │
│           ▼                         ▼               │
│      llm_think Token          custom_block Token    │
└─────────────────────────────────────────────────────┘
                    │
                    ▼
┌─────────────────────────────────────────────────────┐
│                      Parser                         │
│  ┌─────────────────┐    ┌─────────────────────────┐ │
│  │  LlmThinkNode   │    │   CustomBlockNode       │ │
│  │  (专用节点类型)  │    │   (通用节点类型)        │ │
│  └────────┬────────┘    └───────────┬─────────────┘ │
└───────────┼─────────────────────────┼───────────────┘
            │                         │
            ▼                         ▼
┌─────────────────────────────────────────────────────┐
│                   AstNodeRenderer                   │
│  ┌─────────────────┐    ┌─────────────────────────┐ │
│  │ LlmThinkNode.vue│    │   ComponentRegistry     │ │
│  │  (内置组件)      │    │   (动态组件注册表)       │ │
│  └─────────────────┘    └─────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

### 3.2 类型系统设计

新增独立的 `CustomBlockRule` 类型，与现有 `LlmThinkRule` 并列：

```typescript
// src/tools/rich-text-renderer/types.ts

// === 现有类型，保持不变 ===
export interface LlmThinkRule {
  kind: "xml_tag";
  tagName: string;
  displayName: string;
  collapsedByDefault?: boolean;
}

// === 新增类型 ===
export type CustomBlockKind = "delimiter" | "regex";

export interface CustomBlockRule {
  /** 规则唯一标识符 */
  id: string;

  /** 规则类型 */
  kind: CustomBlockKind;

  /** 用于UI显示的名称 */
  displayName: string;

  // --- 定界符模式 (kind: 'delimiter') ---
  /** 起始定界符，例如 '<<<[TOOL_REQUEST]>>>' */
  startDelimiter?: string;
  /** 结束定界符，例如 '<<<[END_TOOL_REQUEST]>>>' */
  endDelimiter?: string;

  // --- 正则模式 (kind: 'regex') ---
  /** 起始匹配正则 */
  startPattern?: RegExp;
  /** 结束匹配正则 */
  endPattern?: RegExp;

  // --- 行为配置 ---
  /** 默认是否折叠 */
  collapsedByDefault?: boolean;
  /** 是否保留原始内容而不解析内部 Markdown */
  rawContent?: boolean;

  // --- AST 映射 ---
  /** 对应的 AST 节点子类型，例如 'vcp_tool_request' */
  subtype: string;
}
```

### 3.3 Tokenizer 改造

Tokenizer 需要支持并行处理 `LlmThinkRule` 和 `CustomBlockRule[]`。

**核心变化**：

1.  **初始化**：接收两套规则，`LlmThinkRule[]` (现有) 和 `CustomBlockRule[]` (新增)。
2.  **处理优先级**：
    - 先检查 `CustomBlockRule`（定界符/正则模式）
    - 再检查 `LlmThinkRule`（XML 标签模式）
    - 最后是标准 Markdown 语法
3.  **Token 生成**：
    - `LlmThinkRule` 生成 `{ type: 'llm_think', ... }` (现有逻辑)
    - `CustomBlockRule` 生成 `{ type: 'custom_block', ruleId: '...', content: '...' }`

**处理流程**：

```
输入文本
    │
    ▼
检查 CustomBlockRule (delimiter/regex)
    │
    ├── 匹配成功 → 生成 custom_block Token
    │
    ▼
检查 LlmThinkRule (XML 标签)
    │
    ├── 匹配成功 → 生成 llm_think Token
    │
    ▼
标准 Markdown 处理
```

### 3.4 AST 节点设计

`LlmThinkNode` 保持不变，新增通用的 `CustomBlockNode`：

```typescript
// src/tools/rich-text-renderer/types.ts

// === 现有节点类型，保持不变 ===
export interface LlmThinkNode extends BaseAstNode {
  type: "llm_think";
  props: {
    tagName: string;
    displayName: string;
    collapsedByDefault: boolean;
  };
  children: AstNode[];
}

// === 新增节点类型 ===
export interface CustomBlockNode extends BaseAstNode {
  type: "custom_block";
  props: {
    /** 对应的规则 ID */
    ruleId: string;
    /** 对应的子类型，用于组件查找 */
    subtype: string;
    /** 显示名称 */
    displayName: string;
    /** 原始内容（定界符之间的内容） */
    rawContent: string;
    /** 解析后的结构化数据（可选，由解析器填充） */
    parsedData?: unknown;
    /** 默认是否折叠 */
    collapsedByDefault?: boolean;
  };
  /** 如果 rawContent: false，则包含解析后的子节点 */
  children: AstNode[];
}
```

**对比说明**：

| 属性     | LlmThinkNode         | CustomBlockNode                     |
| -------- | -------------------- | ----------------------------------- |
| 类型     | `llm_think` (固定)   | `custom_block` (固定)               |
| 子类型   | 通过 `tagName` 区分  | 通过 `subtype` 区分                 |
| 内容处理 | 总是解析子节点       | 可选：`rawContent` 或解析子节点     |
| 来源     | `LlmThinkRule` (XML) | `CustomBlockRule` (delimiter/regex) |

### 3.5 组件渲染层设计

`LlmThinkNode.vue` (现有内置组件) 保持不变，新增 `ComponentRegistry` 用于自定义块的动态组件查找。

```typescript
// src/tools/rich-text-renderer/registry/ComponentRegistry.ts
import type { Component } from "vue";
import DefaultCustomBlockNode from "../components/nodes/DefaultCustomBlockNode.vue";

class ComponentRegistry {
  private customBlockComponents = new Map<string, Component>();

  /**
   * 注册自定义块渲染组件
   * @param subtype 对应 CustomBlockRule.subtype
   * @param component Vue 组件
   */
  registerCustomBlockComponent(subtype: string, component: Component) {
    this.customBlockComponents.set(subtype, component);
  }

  /**
   * 获取自定义块渲染组件
   * @param subtype 对应 CustomBlockNode.props.subtype
   */
  getCustomBlockComponent(subtype: string): Component {
    return this.customBlockComponents.get(subtype) || DefaultCustomBlockNode;
  }
}

export const componentRegistry = new ComponentRegistry();
```

**`AstNodeRenderer.vue` 改造**：

```typescript
// 在 componentMap 中保持 llm_think 的静态映射
const componentMap = {
  // ...现有组件
  llm_think: LlmThinkNode, // 内置，不变
  custom_block: CustomBlockNodeWrapper, // 新增，使用包装组件
};

// CustomBlockNodeWrapper.vue 负责从 registry 动态查找实际组件
```

### 3.6 插件 API 设计

插件可以通过 `context` 独立注册自定义块规则和组件，不影响内置的 `LlmThinkRule` 系统：

```typescript
// 插件激活代码示例
export function activate(context) {
  // 1. 注册解析规则 (CustomBlockRule)
  context.richText.registerCustomBlockRule({
    id: "vcp-tool-request",
    kind: "delimiter",
    startDelimiter: "<<<[TOOL_REQUEST]>>>",
    endDelimiter: "<<<[END_TOOL_REQUEST]>>>",
    displayName: "工具调用",
    subtype: "vcp_tool_request",
    rawContent: true, // VCP 内容不需要 Markdown 解析
  });

  // 2. 注册渲染组件
  context.richText.registerCustomBlockComponent(
    "vcp_tool_request", // 对应 subtype
    VcpToolRequestCard // Vue 组件
  );
}
```

**API 对比**：

| API                              | 作用域    | 用途                          |
| -------------------------------- | --------- | ----------------------------- |
| `LlmThinkRule[]` (内置)          | 预设/内置 | 思考块、推理块等 XML 风格标签 |
| `registerCustomBlockRule()`      | 插件      | VCP 等自定义定界符/正则块     |
| `registerCustomBlockComponent()` | 插件      | 自定义块的渲染组件            |

## 4. 实施路线图

1.  **Phase 1: 类型与基础设施**
    - 新增 `CustomBlockRule` 和 `CustomBlockNode` 类型定义。
    - 实现 `ComponentRegistry` 组件注册表。
    - 实现 `DefaultCustomBlockNode.vue` 默认渲染组件。

2.  **Phase 2: Tokenizer 扩展**
    - 扩展 `Tokenizer` 支持 `CustomBlockRule[]` 输入。
    - 实现 `delimiter` 类型的匹配逻辑。
    - 实现 `regex` 类型的匹配逻辑（可选）。

3.  **Phase 3: 渲染层集成**
    - 实现 `CustomBlockNodeWrapper.vue` 动态组件包装器。
    - 更新 `AstNodeRenderer` 的 `componentMap`。
    - 确保与现有 `LlmThinkNode` 渲染兼容。

4.  **Phase 4: VCP 实现 (示例插件)**
    - 编写 VCP 解析逻辑（解析 `key:「始」value「末」` 格式）。
    - 实现 `VcpToolRequestCard.vue` 专用渲染组件。
    - 注册 VCP 相关的 `CustomBlockRule`。

5.  **Phase 5: 插件 API 暴露**
    - 在插件上下文中暴露 `richText.registerCustomBlockRule()` API。
    - 在插件上下文中暴露 `richText.registerCustomBlockComponent()` API。
    - 编写插件开发文档和示例。

## 5. 架构优势

### 5.1 平行设计的优点

1.  **向后兼容**：`LlmThinkRule` 和相关代码完全不受影响，现有功能稳定。
2.  **独立演进**：两套系统可以独立迭代，互不耦合。
3.  **清晰职责**：
    - `LlmThinkRule`：内置的、XML 风格的思考/推理块（如 `<think>`, `<reasoning>`）。
    - `CustomBlockRule`：插件扩展的、任意定界符/正则风格的自定义块。
4.  **易于理解**：开发者可以快速区分「内置功能」和「扩展点」。

### 5.2 与原方案（继承/泛化）的对比

| 维度       | 原方案（泛化）          | 新方案（平行）       |
| ---------- | ----------------------- | -------------------- |
| 改动范围   | 大，需重构 LlmThinkRule | 小，仅新增           |
| 风险       | 可能影响现有功能        | 隔离，不影响现有功能 |
| 概念复杂度 | 较高（统一抽象）        | 较低（两套独立系统） |
| 灵活性     | 高（统一扩展）          | 中等（分别扩展）     |

## 6. 备选方案 (Quick Fix)

如果短期内无法实现完整的平行架构，可以使用 **预处理钩子 (Preprocessing Hook)** 方案：

1.  利用 `llm-chat` 的 Context Pipeline 或即将实现的 Hook 系统。
2.  在文本传递给渲染器之前，使用正则将 `<<<[TOOL_REQUEST]>>>` 替换为 `<vcp-tool-request>` (XML 标签)。
3.  利用现有的 `LlmThinkRule` (XML 模式) 来识别这些标签。
4.  虽然这破坏了原始文本的精确性（Source Map 偏移），但能快速实现渲染效果。

**注意**：此方案仅作为临时过渡，不推荐长期使用。
