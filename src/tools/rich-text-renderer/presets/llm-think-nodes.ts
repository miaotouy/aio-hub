import { RenderPreset } from '../types';

export const llmThinkNodesPreset: RenderPreset = {
  id: "llm-think-nodes",
  name: "LLM 思考节点测试",
  description: "测试自定义 LLM 思考标签的渲染，包括标准的 <think> 和自定义的 <guguthink> 等",
  content: `# LLM 思考节点渲染测试

## 1. 标准思考标签

这是一个使用标准 \`<think>\` 标签的示例：

<think>
这是标准的思考过程。LLM 在这里进行推理：

1. 分析用户的问题
2. 检索相关知识
3. 构建回答策略
4. 验证逻辑一致性

最终决定：采用分步骤解释的方式回答。
</think>

用户看到的回答内容在这里。

## 2. 自定义思考标签 - guguthink

咕咕的特殊思考过程：

<guguthink>
嗯...让我想想这个问题。

首先，从生物学角度分析：
- 猫头鹰是夜行性动物
- 视觉在黑暗中高度敏锐
- 听觉定位能力极强

然后，结合项目上下文：
- 这是一个 Tauri + Vue 项目
- 使用了富文本渲染系统
- 需要支持自定义标签

结论：这个功能很有趣，值得深入研究。
</guguthink>

所以，我的回答是...

## 3. 嵌套内容测试

思考标签内可以包含复杂的 Markdown 内容：

<think>
### 分析步骤

1. **问题识别**
   - 用户询问关于代码优化的问题
   - 涉及性能和可维护性

2. **解决方案评估**
   
   | 方案 | 优点 | 缺点 |
   |------|------|------|
   | 方案A | 性能好 | 复杂度高 |
   | 方案B | 易维护 | 性能一般 |

3. **代码示例**
   
   \`\`\`typescript
   // 推荐的实现方式
   function optimizedFunction() {
     // ... 优化后的代码
   }
   \`\`\`

4. **最终决策**
   - 采用方案B
   - 理由：可维护性更重要
</think>

基于以上分析，我推荐使用方案B。

## 4. 多个思考块

有时需要多次思考：

<think>
第一阶段思考：理解问题
- 用户想要实现什么？
- 有哪些约束条件？
</think>

中间的一些说明文字...

<guguthink>
第二阶段思考（咕咕模式）：
从猫头鹰的视角来看，这个问题其实很简单。
就像在夜晚捕猎一样，需要：
1. 保持安静（低耦合）
2. 精准定位（明确目标）
3. 一击必中（高效执行）
</guguthink>

最终的回答整合了两个阶段的思考。

## 5. 混合内容

<think>
这是一个包含 **粗体**、*斜体* 和 \`代码\` 的思考过程。

> 引用也可以放在思考里
> 用于强调某些重要观点

- 列表项 1
- 列表项 2
  - 嵌套列表
  - 更多内容
</think>

普通段落文本，包含 [链接](https://example.com) 和其他元素。

## 6. 空思考块

有时思考标签可能为空或只有空白：

<think>
</think>

<guguthink>


</guguthink>

这些应该被正确处理。

## 7. 长思考过程

<think>
这是一个非常长的思考过程，用于测试渲染器的性能和折叠功能。

第一步：问题分解
- 子问题1：数据结构设计
- 子问题2：算法选择
- 子问题3：性能优化
- 子问题4：错误处理

第二步：方案设计
基于上述分解，我们需要：

1. **数据结构**
   \`\`\`typescript
   interface Solution {
     id: string;
     steps: Step[];
     performance: Metrics;
   }
   \`\`\`

2. **算法实现**
   使用分治策略，时间复杂度 O(n log n)

3. **性能指标**
   | 指标 | 目标值 | 实际值 |
   |------|--------|--------|
   | 响应时间 | <100ms | 85ms |
   | 内存占用 | <50MB | 42MB |
   | CPU使用率 | <30% | 25% |

4. **错误边界**
   - 输入验证
   - 异常捕获
   - 降级方案

第三步：实施计划
按照优先级排序：
1. 核心功能实现
2. 性能优化
3. 错误处理
4. 文档完善

第四步：测试验证
- 单元测试
- 集成测试
- 性能测试
- 压力测试

结论：这是一个可行的方案，值得实施。
</think>

## 8. 连续思考块

<think>第一个思考</think>
<guguthink>第二个思考</guguthink>
<think>第三个思考</think>

连续的思考块之间应该有适当的间距。

## 9. 与其他元素混合

### 代码块后的思考

\`\`\`javascript
function example() {
  console.log("示例代码");
}
\`\`\`

<think>
分析上面的代码：
- 函数定义清晰
- 但缺少错误处理
- 建议添加参数验证
</think>

### 表格后的思考

| 特性 | 支持 |
|------|------|
| 思考标签 | ✅ |
| 自定义标签 | ✅ |
| 嵌套内容 | ✅ |

<guguthink>
从表格中可以看出，所有核心特性都已支持。
接下来需要关注的是：
- 性能优化
- 用户体验
- 文档完善
</guguthink>

## 10. 特殊字符测试

<think>
思考内容中包含特殊字符：
- HTML实体：&lt;div&gt;, &amp;, &quot;
- Emoji：🤔 💭 🧠 ✨
- 数学符号：∑ ∏ √ ∞
- 箭头：← → ↑ ↓
</think>

## 总结

以上测试涵盖了：
- ✅ 标准 \`<think>\` 标签
- ✅ 自定义 \`<guguthink>\` 标签
- ✅ 嵌套 Markdown 内容
- ✅ 多个思考块
- ✅ 混合内容场景
- ✅ 长内容折叠
- ✅ 特殊字符处理

所有这些场景都应该被正确渲染为可折叠的卡片样式。`,
};
